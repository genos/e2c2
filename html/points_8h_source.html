<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>e2c2: points.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.9 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
<h1>points.h</h1><a href="points_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00009"></a>00009 <span class="preprocessor">#ifndef _POINTS_H</span>
<a name="l00010"></a>00010 <span class="preprocessor"></span><span class="preprocessor">#define _POINTS_H</span>
<a name="l00011"></a>00011 <span class="preprocessor"></span>
<a name="l00012"></a>00012 <span class="preprocessor">#include &lt;iostream&gt;</span>         <span class="comment">// Readable output</span>
<a name="l00013"></a>00013 <span class="preprocessor">#include &lt;NTL/ZZ.h&gt;</span>         <span class="comment">// Arbitrarily large integers</span>
<a name="l00014"></a>00014 <span class="preprocessor">#include &lt;NTL/ZZ_pE.h&gt;</span>      <span class="comment">// Field elements from @f$ \mathbf{F}_{p^n} @f$</span>
<a name="l00015"></a>00015 <span class="preprocessor">#include &lt;NTL/GF2E.h&gt;</span>       <span class="comment">// Field elements from @f$ \mathbf{F}_{2^n} @f$</span>
<a name="l00016"></a>00016 <span class="preprocessor">#include "<a class="code" href="utilities_8h.html" title="Utilties for Edwards Curves and points on them.">utilities.h</a>"</span>      <span class="comment">// Utilities header for e2c2 project</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include "<a class="code" href="curves_8h.html" title="Edwards Curves over finite fields of prime characteristic.">curves.h</a>"</span>         <span class="comment">// e2c2 curve interface and implementation</span>
<a name="l00018"></a>00018 <span class="preprocessor">#include "<a class="code" href="mol_8h.html" title="Birational Map and utilities from MOL Paper.">mol.h</a>"</span>            <span class="comment">// Birational map and utilities from MOL paper</span>
<a name="l00019"></a>00019 <span class="preprocessor">#include "<a class="code" href="utilities_8h.html" title="Utilties for Edwards Curves and points on them.">utilities.h</a>"</span>      <span class="comment">// e2c2 utilities</span>
<a name="l00020"></a>00020 
<a name="l00021"></a>00021 
<a name="l00023"></a>00023 <span class="keyword">namespace </span>e2c2 {
<a name="l00024"></a>00024     <span class="comment">//------- Helper Function -------//</span>
<a name="l00025"></a>00025 
<a name="l00031"></a><a class="code" href="namespacee2c2.html#81b4cfe5fe88c655195bb82c9dffc4cc">00031</a>     <span class="keyword">inline</span> NTL::ZZ <a class="code" href="namespacee2c2.html#81b4cfe5fe88c655195bb82c9dffc4cc" title="This function counteracts the timing attack outlined in Brumley &amp;amp; Tuveri&amp;#39;s...">counterBTTiming</a>(<span class="keyword">const</span> NTL::ZZ&amp; k, <span class="keyword">const</span> NTL::ZZ&amp; m) {
<a name="l00032"></a>00032         <span class="keywordflow">if</span> (NTL::NumBits(k + m) == NTL::NumBits(m))
<a name="l00033"></a>00033             <span class="keywordflow">return</span> k + 2 * m;
<a name="l00034"></a>00034         <span class="keywordflow">else</span>
<a name="l00035"></a>00035             <span class="keywordflow">return</span> k + m;
<a name="l00036"></a>00036     }
<a name="l00037"></a>00037 
<a name="l00038"></a>00038 
<a name="l00039"></a>00039     <span class="comment">//------- Class Skeletons -------//</span>
<a name="l00040"></a>00040 
<a name="l00048"></a>00048     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Elt, <span class="keyword">class</span> Curve&gt;
<a name="l00049"></a><a class="code" href="classe2c2_1_1_affine.html">00049</a>     <span class="keyword">class </span><a class="code" href="classe2c2_1_1_affine.html" title="Class skeleton for affine points on Edwards Curves.">Affine</a> {
<a name="l00050"></a>00050     <span class="keyword">public</span>:
<a name="l00052"></a><a class="code" href="classe2c2_1_1_affine.html#da98c670d87c0c611e5ffb3e75d97661">00052</a>         Elt <a class="code" href="classe2c2_1_1_affine.html#da98c670d87c0c611e5ffb3e75d97661" title="x-coordinate">x</a>;
<a name="l00053"></a>00053 
<a name="l00055"></a><a class="code" href="classe2c2_1_1_affine.html#013033d305260e31f84064174ca21112">00055</a>         Elt <a class="code" href="classe2c2_1_1_affine.html#013033d305260e31f84064174ca21112" title="y-coordinate">y</a>;
<a name="l00056"></a>00056 
<a name="l00058"></a><a class="code" href="classe2c2_1_1_affine.html#de40baa7dbf5ce6005b3863bd7133d0a">00058</a>         <a class="code" href="classe2c2_1_1_curve.html" title="Base &amp;quot;class&amp;quot; (really class template) for Edwards Curves.">Curve</a> <a class="code" href="classe2c2_1_1_affine.html#de40baa7dbf5ce6005b3863bd7133d0a" title="curve to which this point belongs">curve</a>;
<a name="l00059"></a>00059 
<a name="l00061"></a><a class="code" href="classe2c2_1_1_affine.html#8f02eb09d967018099290a9e8faa3152">00061</a>         <a class="code" href="classe2c2_1_1_affine.html#8f02eb09d967018099290a9e8faa3152" title="Default constructor.">Affine</a>() : <a class="code" href="classe2c2_1_1_affine.html#da98c670d87c0c611e5ffb3e75d97661" title="x-coordinate">x</a>(), <a class="code" href="classe2c2_1_1_affine.html#013033d305260e31f84064174ca21112" title="y-coordinate">y</a>(), <a class="code" href="classe2c2_1_1_affine.html#de40baa7dbf5ce6005b3863bd7133d0a" title="curve to which this point belongs">curve</a>() {}
<a name="l00062"></a>00062 
<a name="l00064"></a><a class="code" href="classe2c2_1_1_affine.html#96f07f8b434b1c23b2287fc4a96970cb">00064</a>         <a class="code" href="classe2c2_1_1_affine.html#96f07f8b434b1c23b2287fc4a96970cb" title="Destructor.">~Affine</a>() {}
<a name="l00065"></a>00065 
<a name="l00067"></a><a class="code" href="classe2c2_1_1_affine.html#804e3b30c4e5be297ac5920959a6008b">00067</a>         <a class="code" href="classe2c2_1_1_affine.html#8f02eb09d967018099290a9e8faa3152" title="Default constructor.">Affine</a>(<span class="keyword">const</span> Elt&amp; <a class="code" href="classe2c2_1_1_affine.html#da98c670d87c0c611e5ffb3e75d97661" title="x-coordinate">x</a>, <span class="keyword">const</span> Elt&amp; <a class="code" href="classe2c2_1_1_affine.html#013033d305260e31f84064174ca21112" title="y-coordinate">y</a>, <span class="keyword">const</span> <a class="code" href="classe2c2_1_1_curve.html" title="Base &amp;quot;class&amp;quot; (really class template) for Edwards Curves.">Curve</a>&amp; <a class="code" href="classe2c2_1_1_affine.html#de40baa7dbf5ce6005b3863bd7133d0a" title="curve to which this point belongs">curve</a>) :
<a name="l00068"></a>00068                 x(x), y(y), curve(curve) {
<a name="l00069"></a>00069             <span class="keywordflow">if</span> (!<a class="code" href="namespacee2c2.html#bcccf8194e5a39be0e92635160d0b4aa" title="Validation of point coordinates.">curveEquation</a>(curve, x, y))
<a name="l00070"></a>00070                 <span class="keywordflow">throw</span> <a class="code" href="classe2c2_1_1_invalid_parameters_exception.html" title="Custom exception to be thrown when building a curve with invalid parameters.">InvalidParametersException</a>();
<a name="l00071"></a>00071         }
<a name="l00072"></a>00072 
<a name="l00074"></a><a class="code" href="classe2c2_1_1_affine.html#126dbea82afe1ec80ab7fd513c72afd9">00074</a>         <a class="code" href="classe2c2_1_1_affine.html#126dbea82afe1ec80ab7fd513c72afd9" title="Constructor if given just a curve (left to specific classes).">Affine</a>(<span class="keyword">const</span> <a class="code" href="classe2c2_1_1_curve.html" title="Base &amp;quot;class&amp;quot; (really class template) for Edwards Curves.">Curve</a>&amp; <a class="code" href="classe2c2_1_1_affine.html#de40baa7dbf5ce6005b3863bd7133d0a" title="curve to which this point belongs">curve</a>) : <a class="code" href="classe2c2_1_1_affine.html#da98c670d87c0c611e5ffb3e75d97661" title="x-coordinate">x</a>(), <a class="code" href="classe2c2_1_1_affine.html#013033d305260e31f84064174ca21112" title="y-coordinate">y</a>(), curve(curve) {
<a name="l00075"></a>00075             *<span class="keyword">this</span> = <a class="code" href="namespacee2c2.html#6be24594df790c851dd9a353717c6ade" title="Affine neutral element on odd curve.">aff_id</a>(curve);
<a name="l00076"></a>00076         }
<a name="l00077"></a>00077 
<a name="l00079"></a><a class="code" href="classe2c2_1_1_affine.html#004399090aec2b8924892c06634501c7">00079</a>         <span class="keywordtype">bool</span> <a class="code" href="classe2c2_1_1_affine.html#004399090aec2b8924892c06634501c7" title="Checking whether we have the neutral element.">isID</a>()<span class="keyword"> const </span>{
<a name="l00080"></a>00080             <span class="keywordflow">return</span> *<span class="keyword">this</span> == <a class="code" href="classe2c2_1_1_affine.html#8f02eb09d967018099290a9e8faa3152" title="Default constructor.">Affine</a>(this-&gt;<a class="code" href="classe2c2_1_1_affine.html#de40baa7dbf5ce6005b3863bd7133d0a" title="curve to which this point belongs">curve</a>);
<a name="l00081"></a>00081         }
<a name="l00082"></a>00082 
<a name="l00084"></a><a class="code" href="classe2c2_1_1_affine.html#034299e189dcae69966d47d209ab6723">00084</a>         <span class="keywordtype">bool</span> <a class="code" href="classe2c2_1_1_affine.html#034299e189dcae69966d47d209ab6723" title="Two affine points are equal if all relevant info is the same...">operator==</a>(<span class="keyword">const</span> <a class="code" href="classe2c2_1_1_affine.html" title="Class skeleton for affine points on Edwards Curves.">Affine</a>&amp; that)<span class="keyword"> const </span>{
<a name="l00085"></a>00085             <span class="keywordflow">return</span> (<a class="code" href="classe2c2_1_1_affine.html#da98c670d87c0c611e5ffb3e75d97661" title="x-coordinate">x</a> == that.<a class="code" href="classe2c2_1_1_affine.html#da98c670d87c0c611e5ffb3e75d97661" title="x-coordinate">x</a>) &amp;&amp; (<a class="code" href="classe2c2_1_1_affine.html#013033d305260e31f84064174ca21112" title="y-coordinate">y</a> == that.<a class="code" href="classe2c2_1_1_affine.html#013033d305260e31f84064174ca21112" title="y-coordinate">y</a>) &amp;&amp; (<a class="code" href="classe2c2_1_1_affine.html#de40baa7dbf5ce6005b3863bd7133d0a" title="curve to which this point belongs">curve</a> == that.<a class="code" href="classe2c2_1_1_affine.html#de40baa7dbf5ce6005b3863bd7133d0a" title="curve to which this point belongs">curve</a>);
<a name="l00086"></a>00086         }
<a name="l00087"></a>00087 
<a name="l00089"></a><a class="code" href="classe2c2_1_1_affine.html#47c4e95863fc2958f3e5f3b5678491a6">00089</a>         <span class="keywordtype">bool</span> <a class="code" href="classe2c2_1_1_affine.html#47c4e95863fc2958f3e5f3b5678491a6" title="...and are not equal otherwise">operator !=</a>(<span class="keyword">const</span> <a class="code" href="classe2c2_1_1_affine.html" title="Class skeleton for affine points on Edwards Curves.">Affine</a>&amp; that)<span class="keyword"> const </span>{
<a name="l00090"></a>00090             <span class="keywordflow">return</span> !(*<span class="keyword">this</span> == that);
<a name="l00091"></a>00091         }
<a name="l00092"></a>00092 
<a name="l00094"></a><a class="code" href="classe2c2_1_1_affine.html#1bb0823ffe77e7327a6cc5e325bca24f">00094</a>         <a class="code" href="classe2c2_1_1_affine.html" title="Class skeleton for affine points on Edwards Curves.">Affine</a>&amp; <a class="code" href="classe2c2_1_1_affine.html#1bb0823ffe77e7327a6cc5e325bca24f" title="Assignment by addition; left to fleshed-out classes.">operator+=</a>(<span class="keyword">const</span> <a class="code" href="classe2c2_1_1_affine.html" title="Class skeleton for affine points on Edwards Curves.">Affine</a>&amp; that) {
<a name="l00095"></a>00095             <span class="keywordflow">if</span> (this-&gt;<a class="code" href="classe2c2_1_1_affine.html#de40baa7dbf5ce6005b3863bd7133d0a" title="curve to which this point belongs">curve</a> != that.<a class="code" href="classe2c2_1_1_affine.html#de40baa7dbf5ce6005b3863bd7133d0a" title="curve to which this point belongs">curve</a>)
<a name="l00096"></a>00096                 <span class="keywordflow">throw</span> <a class="code" href="classe2c2_1_1_different_curves_exception.html" title="Custom exception to be thrown when attempting to operate on points from different...">DifferentCurvesException</a>();
<a name="l00097"></a>00097 
<a name="l00098"></a>00098             *<span class="keyword">this</span> = <a class="code" href="namespacee2c2.html#bced6b0a7b0bb724367daccb960bd373" title="Affine addition for points on an odd curve.">aff_add</a>(*<span class="keyword">this</span>, that);
<a name="l00099"></a>00099             <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00100"></a>00100         }
<a name="l00101"></a>00101 
<a name="l00103"></a><a class="code" href="classe2c2_1_1_affine.html#a7a3078b39be470caef0e98ce348c9f2">00103</a>         <a class="code" href="classe2c2_1_1_affine.html" title="Class skeleton for affine points on Edwards Curves.">Affine</a> <a class="code" href="classe2c2_1_1_affine.html#a7a3078b39be470caef0e98ce348c9f2" title="Negation of a point; left to full class.">operator-</a>()<span class="keyword"> const </span>{
<a name="l00104"></a>00104             <span class="keywordflow">return</span> <a class="code" href="namespacee2c2.html#7af88d3a6e3c922faa355b316c42d673" title="Negation of an affine point on an odd curve.">aff_neg</a>(*<span class="keyword">this</span>);
<a name="l00105"></a>00105         }
<a name="l00106"></a>00106 
<a name="l00108"></a><a class="code" href="classe2c2_1_1_affine.html#b688f5a447312cd12f2293b6a9301670">00108</a>         <a class="code" href="classe2c2_1_1_affine.html" title="Class skeleton for affine points on Edwards Curves.">Affine</a>&amp; <a class="code" href="classe2c2_1_1_affine.html#b688f5a447312cd12f2293b6a9301670" title="Assignment by subtraction; makes use of += and -.">operator-=</a>(<span class="keyword">const</span> <a class="code" href="classe2c2_1_1_affine.html" title="Class skeleton for affine points on Edwards Curves.">Affine</a>&amp; that) {
<a name="l00109"></a>00109             <span class="keywordflow">return</span> *<span class="keyword">this</span> += -that;
<a name="l00110"></a>00110         }
<a name="l00111"></a>00111 
<a name="l00113"></a><a class="code" href="classe2c2_1_1_affine.html#73dd170071825394c39426f88f590156">00113</a>         <a class="code" href="classe2c2_1_1_affine.html" title="Class skeleton for affine points on Edwards Curves.">Affine</a> <a class="code" href="classe2c2_1_1_affine.html#73dd170071825394c39426f88f590156" title="Addition via +=.">operator+</a>(<span class="keyword">const</span> <a class="code" href="classe2c2_1_1_affine.html" title="Class skeleton for affine points on Edwards Curves.">Affine</a>&amp; that)<span class="keyword"> const </span>{
<a name="l00114"></a>00114             <span class="keywordflow">return</span> <a class="code" href="classe2c2_1_1_affine.html#8f02eb09d967018099290a9e8faa3152" title="Default constructor.">Affine</a>(*<span class="keyword">this</span>) += that;
<a name="l00115"></a>00115         }
<a name="l00116"></a>00116 
<a name="l00118"></a><a class="code" href="classe2c2_1_1_affine.html#d5fc15e66eb44e4f9e0ad492236a6dd1">00118</a>         <a class="code" href="classe2c2_1_1_affine.html" title="Class skeleton for affine points on Edwards Curves.">Affine</a> <a class="code" href="classe2c2_1_1_affine.html#d5fc15e66eb44e4f9e0ad492236a6dd1" title="Subtraction via -=.">operator-</a>(<span class="keyword">const</span> <a class="code" href="classe2c2_1_1_affine.html" title="Class skeleton for affine points on Edwards Curves.">Affine</a>&amp; that)<span class="keyword"> const </span>{
<a name="l00119"></a>00119             <span class="keywordflow">return</span> <a class="code" href="classe2c2_1_1_affine.html#8f02eb09d967018099290a9e8faa3152" title="Default constructor.">Affine</a>(*<span class="keyword">this</span>) -= that;
<a name="l00120"></a>00120         }
<a name="l00121"></a>00121 
<a name="l00123"></a><a class="code" href="classe2c2_1_1_affine.html#68982b7dece7ce8e7b726400be53cf1b">00123</a>         <a class="code" href="classe2c2_1_1_affine.html" title="Class skeleton for affine points on Edwards Curves.">Affine</a> <a class="code" href="classe2c2_1_1_affine.html#68982b7dece7ce8e7b726400be53cf1b" title="Point doubling; left to full class.">pointDouble</a>()<span class="keyword"> const </span>{
<a name="l00124"></a>00124             <span class="keywordflow">return</span> <a class="code" href="namespacee2c2.html#513a9ef3d910317b835b1008a81d9400" title="Affine point doubling on odd curve.">aff_double</a>(*<span class="keyword">this</span>);
<a name="l00125"></a>00125         }
<a name="l00126"></a>00126 
<a name="l00128"></a><a class="code" href="classe2c2_1_1_affine.html#12b2d95bea7f2d37a163aae624b66e72">00128</a>         <a class="code" href="classe2c2_1_1_affine.html" title="Class skeleton for affine points on Edwards Curves.">Affine</a> <a class="code" href="classe2c2_1_1_affine.html#12b2d95bea7f2d37a163aae624b66e72" title="Montgomery Ladder for scalar multiplication.">montgomery</a>(<span class="keyword">const</span> NTL::ZZ&amp; k)<span class="keyword"> const </span>{
<a name="l00129"></a>00129             <span class="comment">// Work with positive scalars</span>
<a name="l00130"></a>00130             <span class="keywordflow">if</span> (k &lt; 0)
<a name="l00131"></a>00131                 <span class="keywordflow">return</span> (-(*<span class="keyword">this</span>)).<a class="code" href="classe2c2_1_1_affine.html#12b2d95bea7f2d37a163aae624b66e72" title="Montgomery Ladder for scalar multiplication.">montgomery</a>(-k);
<a name="l00132"></a>00132 
<a name="l00133"></a>00133             <span class="comment">// Counteract Brumley &amp; Tuveri's timing attack</span>
<a name="l00134"></a>00134             NTL::ZZ kk = <a class="code" href="namespacee2c2.html#81b4cfe5fe88c655195bb82c9dffc4cc" title="This function counteracts the timing attack outlined in Brumley &amp;amp; Tuveri&amp;#39;s...">counterBTTiming</a>(k, <a class="code" href="classe2c2_1_1_affine.html#de40baa7dbf5ce6005b3863bd7133d0a" title="curve to which this point belongs">curve</a>.<a class="code" href="classe2c2_1_1_curve.html#1468b9ede88d740fa8aac06130929d0b" title="Number of rational points on curve over field.">cardinality</a>());
<a name="l00135"></a>00135 
<a name="l00136"></a>00136             <a class="code" href="classe2c2_1_1_affine.html" title="Class skeleton for affine points on Edwards Curves.">Affine</a> aTmp(<a class="code" href="classe2c2_1_1_affine.html#de40baa7dbf5ce6005b3863bd7133d0a" title="curve to which this point belongs">curve</a>);  <span class="comment">// identity element</span>
<a name="l00137"></a>00137             <a class="code" href="classe2c2_1_1_affine.html" title="Class skeleton for affine points on Edwards Curves.">Affine</a> bTmp(*<span class="keyword">this</span>);
<a name="l00138"></a>00138             <span class="keywordflow">for</span> (<span class="keyword">auto</span> i = NumBits(kk) - 1; i &gt;= 0; i--) {
<a name="l00139"></a>00139                 <span class="keywordflow">if</span> (bit(k, i)) {
<a name="l00140"></a>00140                     aTmp += bTmp;
<a name="l00141"></a>00141                     bTmp = bTmp.<a class="code" href="classe2c2_1_1_affine.html#68982b7dece7ce8e7b726400be53cf1b" title="Point doubling; left to full class.">pointDouble</a>();
<a name="l00142"></a>00142                 } <span class="keywordflow">else</span> {
<a name="l00143"></a>00143                     bTmp += aTmp;
<a name="l00144"></a>00144                     aTmp = aTmp.<a class="code" href="classe2c2_1_1_affine.html#68982b7dece7ce8e7b726400be53cf1b" title="Point doubling; left to full class.">pointDouble</a>();
<a name="l00145"></a>00145                 }
<a name="l00146"></a>00146             }
<a name="l00147"></a>00147             <span class="keywordflow">return</span> aTmp;
<a name="l00148"></a>00148         }
<a name="l00149"></a>00149 
<a name="l00151"></a><a class="code" href="classe2c2_1_1_affine.html#59fe87f7e3e6d43e36afab5602031f93">00151</a>         <a class="code" href="classe2c2_1_1_affine.html" title="Class skeleton for affine points on Edwards Curves.">Affine</a>&amp; <a class="code" href="classe2c2_1_1_affine.html#59fe87f7e3e6d43e36afab5602031f93" title="Assignment by scalar multiplication (using Montgomery Ladder).">operator*=</a>(<span class="keyword">const</span> NTL::ZZ&amp; k) {
<a name="l00152"></a>00152             <span class="keywordflow">return</span> *<span class="keyword">this</span> = <a class="code" href="classe2c2_1_1_affine.html#12b2d95bea7f2d37a163aae624b66e72" title="Montgomery Ladder for scalar multiplication.">montgomery</a>(k);
<a name="l00153"></a>00153         }
<a name="l00154"></a>00154 
<a name="l00156"></a>00156         <span class="keyword">template</span> &lt;<span class="keyword">class</span> N&gt;
<a name="l00157"></a><a class="code" href="classe2c2_1_1_affine.html#1546b9d6930d86e7ed7fbf44c4f720c1">00157</a>         <a class="code" href="classe2c2_1_1_affine.html" title="Class skeleton for affine points on Edwards Curves.">Affine</a>&amp; <a class="code" href="classe2c2_1_1_affine.html#1546b9d6930d86e7ed7fbf44c4f720c1" title="Assignment by scalar multiplication (using Montgomery Ladder).">operator*=</a>(<span class="keyword">const</span> N&amp; k) {
<a name="l00158"></a>00158             <span class="keywordflow">return</span> *<span class="keyword">this</span> = <a class="code" href="classe2c2_1_1_affine.html#12b2d95bea7f2d37a163aae624b66e72" title="Montgomery Ladder for scalar multiplication.">montgomery</a>(NTL::to_ZZ(k));
<a name="l00159"></a>00159         }
<a name="l00160"></a>00160 
<a name="l00163"></a><a class="code" href="classe2c2_1_1_affine.html#703caaa3c12db6b0038b4b9d89643bc1">00163</a>         <span class="keyword">friend</span> <a class="code" href="classe2c2_1_1_affine.html" title="Class skeleton for affine points on Edwards Curves.">Affine</a> <a class="code" href="classe2c2_1_1_affine.html#703caaa3c12db6b0038b4b9d89643bc1">operator*</a>(<span class="keyword">const</span> NTL::ZZ&amp; k, <span class="keyword">const</span> <a class="code" href="classe2c2_1_1_affine.html" title="Class skeleton for affine points on Edwards Curves.">Affine</a>&amp; point) {
<a name="l00164"></a>00164             <span class="keywordflow">return</span> <a class="code" href="classe2c2_1_1_affine.html#8f02eb09d967018099290a9e8faa3152" title="Default constructor.">Affine</a>(point) *= k;
<a name="l00165"></a>00165         }
<a name="l00166"></a>00166 
<a name="l00169"></a>00169         <span class="keyword">template</span> &lt;<span class="keyword">class</span> N&gt;
<a name="l00170"></a><a class="code" href="classe2c2_1_1_affine.html#00d1a11dfa2b2159c1f7116a2986ae4e">00170</a>         <span class="keyword">friend</span> <a class="code" href="classe2c2_1_1_affine.html" title="Class skeleton for affine points on Edwards Curves.">Affine</a> <a class="code" href="classe2c2_1_1_affine.html#00d1a11dfa2b2159c1f7116a2986ae4e">operator*</a>(<span class="keyword">const</span> N&amp; k, <span class="keyword">const</span> <a class="code" href="classe2c2_1_1_affine.html" title="Class skeleton for affine points on Edwards Curves.">Affine</a>&amp; point) {
<a name="l00171"></a>00171             <span class="keywordflow">return</span> <a class="code" href="classe2c2_1_1_affine.html#8f02eb09d967018099290a9e8faa3152" title="Default constructor.">Affine</a>(point) *= NTL::to_ZZ(k);
<a name="l00172"></a>00172         }
<a name="l00173"></a>00173 
<a name="l00175"></a><a class="code" href="classe2c2_1_1_affine.html#c9baa6e235553f1536474c40f0d85ef7">00175</a>         <span class="keyword">friend</span> std::ostream&amp; <a class="code" href="classe2c2_1_1_affine.html#c9baa6e235553f1536474c40f0d85ef7" title="Output.">operator&lt;&lt;</a>(std::ostream&amp; out, <span class="keyword">const</span> <a class="code" href="classe2c2_1_1_affine.html" title="Class skeleton for affine points on Edwards Curves.">Affine</a>&amp;
<a name="l00176"></a>00176                                         point) {
<a name="l00177"></a>00177             <span class="keywordflow">return</span> (out &lt;&lt;<span class="stringliteral">"("</span> &lt;&lt; point.<a class="code" href="classe2c2_1_1_affine.html#da98c670d87c0c611e5ffb3e75d97661" title="x-coordinate">x</a> &lt;&lt; <span class="stringliteral">", "</span> &lt;&lt; point.<a class="code" href="classe2c2_1_1_affine.html#013033d305260e31f84064174ca21112" title="y-coordinate">y</a> &lt;&lt; <span class="stringliteral">")"</span>);
<a name="l00178"></a>00178         }
<a name="l00179"></a>00179     };
<a name="l00180"></a>00180 
<a name="l00181"></a>00181 
<a name="l00189"></a>00189     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Elt, <span class="keyword">class</span> Curve&gt;
<a name="l00190"></a><a class="code" href="classe2c2_1_1_projective.html">00190</a>     <span class="keyword">class </span><a class="code" href="classe2c2_1_1_projective.html" title="Class skeleton for projective points on Edwards Curves.">Projective</a> {
<a name="l00191"></a>00191     <span class="keyword">public</span>:
<a name="l00193"></a><a class="code" href="classe2c2_1_1_projective.html#4cf72186f8bd222ffcb6d80a3852043f">00193</a>         Elt <a class="code" href="classe2c2_1_1_projective.html#4cf72186f8bd222ffcb6d80a3852043f" title="x-coordinate">x</a>;
<a name="l00194"></a>00194 
<a name="l00196"></a><a class="code" href="classe2c2_1_1_projective.html#77b28886ad808c12a1889476c5e546e2">00196</a>         Elt <a class="code" href="classe2c2_1_1_projective.html#77b28886ad808c12a1889476c5e546e2" title="y-coordinate">y</a>;
<a name="l00197"></a>00197 
<a name="l00199"></a><a class="code" href="classe2c2_1_1_projective.html#3f29811c0d05e61d14ff5fae2b0aca6a">00199</a>         Elt <a class="code" href="classe2c2_1_1_projective.html#3f29811c0d05e61d14ff5fae2b0aca6a" title="z-coordinate">z</a>;
<a name="l00200"></a>00200 
<a name="l00202"></a><a class="code" href="classe2c2_1_1_projective.html#551a78ebbaae16a790528a87ecfdd318">00202</a>         <a class="code" href="classe2c2_1_1_curve.html" title="Base &amp;quot;class&amp;quot; (really class template) for Edwards Curves.">Curve</a> <a class="code" href="classe2c2_1_1_projective.html#551a78ebbaae16a790528a87ecfdd318" title="curve to which this point belongs">curve</a>;
<a name="l00203"></a>00203 
<a name="l00205"></a><a class="code" href="classe2c2_1_1_projective.html#252dda5ce288da82a1eb8b1856463100">00205</a>         <a class="code" href="classe2c2_1_1_projective.html#252dda5ce288da82a1eb8b1856463100" title="Default constructor.">Projective</a>() : <a class="code" href="classe2c2_1_1_projective.html#4cf72186f8bd222ffcb6d80a3852043f" title="x-coordinate">x</a>(), <a class="code" href="classe2c2_1_1_projective.html#77b28886ad808c12a1889476c5e546e2" title="y-coordinate">y</a>(), <a class="code" href="classe2c2_1_1_projective.html#3f29811c0d05e61d14ff5fae2b0aca6a" title="z-coordinate">z</a>(), <a class="code" href="classe2c2_1_1_projective.html#551a78ebbaae16a790528a87ecfdd318" title="curve to which this point belongs">curve</a>() {}
<a name="l00206"></a>00206 
<a name="l00208"></a><a class="code" href="classe2c2_1_1_projective.html#d0d79e895674fb9a0c8eca65bc9462a3">00208</a>         <a class="code" href="classe2c2_1_1_projective.html#d0d79e895674fb9a0c8eca65bc9462a3" title="Destructor.">~Projective</a>() {}
<a name="l00209"></a>00209 
<a name="l00211"></a><a class="code" href="classe2c2_1_1_projective.html#03b2cfdf84808053135d1c8e632b60cc">00211</a>         <a class="code" href="classe2c2_1_1_projective.html#252dda5ce288da82a1eb8b1856463100" title="Default constructor.">Projective</a>(<span class="keyword">const</span> Elt&amp; <a class="code" href="classe2c2_1_1_projective.html#4cf72186f8bd222ffcb6d80a3852043f" title="x-coordinate">x</a>, <span class="keyword">const</span> Elt&amp; <a class="code" href="classe2c2_1_1_projective.html#77b28886ad808c12a1889476c5e546e2" title="y-coordinate">y</a>, <span class="keyword">const</span> Elt&amp; <a class="code" href="classe2c2_1_1_projective.html#3f29811c0d05e61d14ff5fae2b0aca6a" title="z-coordinate">z</a>,
<a name="l00212"></a>00212                 <span class="keyword">const</span> <a class="code" href="classe2c2_1_1_curve.html" title="Base &amp;quot;class&amp;quot; (really class template) for Edwards Curves.">Curve</a>&amp; <a class="code" href="classe2c2_1_1_projective.html#551a78ebbaae16a790528a87ecfdd318" title="curve to which this point belongs">curve</a>) : x(x), y(y), z(z), curve(curve) {
<a name="l00213"></a>00213             <span class="keywordflow">if</span> (!<a class="code" href="namespacee2c2.html#bcccf8194e5a39be0e92635160d0b4aa" title="Validation of point coordinates.">curveEquation</a>(curve, x / z, y / z))
<a name="l00214"></a>00214                 <span class="keywordflow">throw</span> <a class="code" href="classe2c2_1_1_invalid_parameters_exception.html" title="Custom exception to be thrown when building a curve with invalid parameters.">InvalidParametersException</a>();
<a name="l00215"></a>00215         }
<a name="l00216"></a>00216 
<a name="l00218"></a><a class="code" href="classe2c2_1_1_projective.html#bb46e7e12c064ab54549d2addbe5cfbe">00218</a>         <a class="code" href="classe2c2_1_1_projective.html#bb46e7e12c064ab54549d2addbe5cfbe" title="Constructor if given just a curve (left to specific class).">Projective</a>(<span class="keyword">const</span> <a class="code" href="classe2c2_1_1_curve.html" title="Base &amp;quot;class&amp;quot; (really class template) for Edwards Curves.">Curve</a>&amp; <a class="code" href="classe2c2_1_1_projective.html#551a78ebbaae16a790528a87ecfdd318" title="curve to which this point belongs">curve</a>) : <a class="code" href="classe2c2_1_1_projective.html#4cf72186f8bd222ffcb6d80a3852043f" title="x-coordinate">x</a>(), <a class="code" href="classe2c2_1_1_projective.html#77b28886ad808c12a1889476c5e546e2" title="y-coordinate">y</a>(), <a class="code" href="classe2c2_1_1_projective.html#3f29811c0d05e61d14ff5fae2b0aca6a" title="z-coordinate">z</a>(), curve(curve) {
<a name="l00219"></a>00219             *<span class="keyword">this</span> = <a class="code" href="namespacee2c2.html#9aaff940aad3bd38fe3e141added00c7" title="Projective neutral element on odd curve.">proj_id</a>(curve);
<a name="l00220"></a>00220         }
<a name="l00221"></a>00221 
<a name="l00223"></a><a class="code" href="classe2c2_1_1_projective.html#b6b971e7ae83488053fadee708b97079">00223</a>         <span class="keyword">explicit</span> <a class="code" href="classe2c2_1_1_projective.html#252dda5ce288da82a1eb8b1856463100" title="Default constructor.">Projective</a>(<span class="keyword">const</span> <a class="code" href="classe2c2_1_1_affine.html" title="Class skeleton for affine points on Edwards Curves.">Affine&lt;Elt, Curve&gt;</a>&amp; a) : <a class="code" href="classe2c2_1_1_projective.html#4cf72186f8bd222ffcb6d80a3852043f" title="x-coordinate">x</a>(a.<a class="code" href="classe2c2_1_1_projective.html#4cf72186f8bd222ffcb6d80a3852043f" title="x-coordinate">x</a>), <a class="code" href="classe2c2_1_1_projective.html#77b28886ad808c12a1889476c5e546e2" title="y-coordinate">y</a>(a.<a class="code" href="classe2c2_1_1_projective.html#77b28886ad808c12a1889476c5e546e2" title="y-coordinate">y</a>), <a class="code" href="classe2c2_1_1_projective.html#3f29811c0d05e61d14ff5fae2b0aca6a" title="z-coordinate">z</a>(),
<a name="l00224"></a>00224                 <a class="code" href="classe2c2_1_1_projective.html#551a78ebbaae16a790528a87ecfdd318" title="curve to which this point belongs">curve</a>(a.<a class="code" href="classe2c2_1_1_projective.html#551a78ebbaae16a790528a87ecfdd318" title="curve to which this point belongs">curve</a>) {
<a name="l00225"></a>00225             <a class="code" href="classe2c2_1_1_projective.html#3f29811c0d05e61d14ff5fae2b0aca6a" title="z-coordinate">z</a> = 1;
<a name="l00226"></a>00226             <span class="keywordflow">if</span> (!<a class="code" href="namespacee2c2.html#bcccf8194e5a39be0e92635160d0b4aa" title="Validation of point coordinates.">curveEquation</a>(<a class="code" href="classe2c2_1_1_projective.html#551a78ebbaae16a790528a87ecfdd318" title="curve to which this point belongs">curve</a>, <a class="code" href="classe2c2_1_1_projective.html#4cf72186f8bd222ffcb6d80a3852043f" title="x-coordinate">x</a> / <a class="code" href="classe2c2_1_1_projective.html#3f29811c0d05e61d14ff5fae2b0aca6a" title="z-coordinate">z</a>, <a class="code" href="classe2c2_1_1_projective.html#77b28886ad808c12a1889476c5e546e2" title="y-coordinate">y</a> / <a class="code" href="classe2c2_1_1_projective.html#3f29811c0d05e61d14ff5fae2b0aca6a" title="z-coordinate">z</a>))
<a name="l00227"></a>00227                 <span class="keywordflow">throw</span> <a class="code" href="classe2c2_1_1_invalid_parameters_exception.html" title="Custom exception to be thrown when building a curve with invalid parameters.">InvalidParametersException</a>();
<a name="l00228"></a>00228         }
<a name="l00229"></a>00229 
<a name="l00231"></a><a class="code" href="classe2c2_1_1_projective.html#feb1a0b17cfc95fd1676ec8c09b99e5e">00231</a>         <a class="code" href="classe2c2_1_1_projective.html" title="Class skeleton for projective points on Edwards Curves.">Projective</a> <a class="code" href="classe2c2_1_1_projective.html#feb1a0b17cfc95fd1676ec8c09b99e5e" title="Equivalence class representative: z = 1.">equivalenceClassRep</a>()<span class="keyword"> const </span>{
<a name="l00232"></a>00232             Elt one;
<a name="l00233"></a>00233             one = 1;
<a name="l00234"></a>00234             <span class="keywordflow">return</span> <a class="code" href="classe2c2_1_1_projective.html#252dda5ce288da82a1eb8b1856463100" title="Default constructor.">Projective</a>(<a class="code" href="classe2c2_1_1_projective.html#4cf72186f8bd222ffcb6d80a3852043f" title="x-coordinate">x</a> / <a class="code" href="classe2c2_1_1_projective.html#3f29811c0d05e61d14ff5fae2b0aca6a" title="z-coordinate">z</a>, <a class="code" href="classe2c2_1_1_projective.html#77b28886ad808c12a1889476c5e546e2" title="y-coordinate">y</a> / <a class="code" href="classe2c2_1_1_projective.html#3f29811c0d05e61d14ff5fae2b0aca6a" title="z-coordinate">z</a>, one, <a class="code" href="classe2c2_1_1_projective.html#551a78ebbaae16a790528a87ecfdd318" title="curve to which this point belongs">curve</a>);
<a name="l00235"></a>00235         }
<a name="l00236"></a>00236 
<a name="l00238"></a><a class="code" href="classe2c2_1_1_projective.html#e566e7f66a4fa404503ea86b5717ca30">00238</a>         <span class="keywordtype">bool</span> <a class="code" href="classe2c2_1_1_projective.html#e566e7f66a4fa404503ea86b5717ca30" title="Checking whether we have the neutral element.">isID</a>()<span class="keyword"> const </span>{
<a name="l00239"></a>00239             <span class="keywordflow">return</span> *<span class="keyword">this</span> == <a class="code" href="classe2c2_1_1_projective.html#252dda5ce288da82a1eb8b1856463100" title="Default constructor.">Projective</a>(this-&gt;<a class="code" href="classe2c2_1_1_projective.html#551a78ebbaae16a790528a87ecfdd318" title="curve to which this point belongs">curve</a>);
<a name="l00240"></a>00240         }
<a name="l00241"></a>00241 
<a name="l00244"></a><a class="code" href="classe2c2_1_1_projective.html#edff7cc9302ed78ba3705ab12b66a44b">00244</a>         <span class="keywordtype">bool</span> <a class="code" href="classe2c2_1_1_projective.html#edff7cc9302ed78ba3705ab12b66a44b">operator==</a>(<span class="keyword">const</span> <a class="code" href="classe2c2_1_1_projective.html" title="Class skeleton for projective points on Edwards Curves.">Projective</a>&amp; that)<span class="keyword"> const </span>{
<a name="l00245"></a>00245             <span class="keywordflow">return</span> (<a class="code" href="classe2c2_1_1_projective.html#4cf72186f8bd222ffcb6d80a3852043f" title="x-coordinate">x</a> / <a class="code" href="classe2c2_1_1_projective.html#3f29811c0d05e61d14ff5fae2b0aca6a" title="z-coordinate">z</a> == that.<a class="code" href="classe2c2_1_1_projective.html#4cf72186f8bd222ffcb6d80a3852043f" title="x-coordinate">x</a> / that.<a class="code" href="classe2c2_1_1_projective.html#3f29811c0d05e61d14ff5fae2b0aca6a" title="z-coordinate">z</a>) &amp;&amp; (<a class="code" href="classe2c2_1_1_projective.html#77b28886ad808c12a1889476c5e546e2" title="y-coordinate">y</a> / <a class="code" href="classe2c2_1_1_projective.html#3f29811c0d05e61d14ff5fae2b0aca6a" title="z-coordinate">z</a> == that.<a class="code" href="classe2c2_1_1_projective.html#77b28886ad808c12a1889476c5e546e2" title="y-coordinate">y</a> / that.<a class="code" href="classe2c2_1_1_projective.html#3f29811c0d05e61d14ff5fae2b0aca6a" title="z-coordinate">z</a>) &amp;&amp;
<a name="l00246"></a>00246                 (<a class="code" href="classe2c2_1_1_projective.html#551a78ebbaae16a790528a87ecfdd318" title="curve to which this point belongs">curve</a> == that.<a class="code" href="classe2c2_1_1_projective.html#551a78ebbaae16a790528a87ecfdd318" title="curve to which this point belongs">curve</a>);
<a name="l00247"></a>00247         }
<a name="l00248"></a>00248 
<a name="l00250"></a><a class="code" href="classe2c2_1_1_projective.html#b2b98c6eb23ad3bf97a8129fe2bbdc4f">00250</a>         <span class="keywordtype">bool</span> <a class="code" href="classe2c2_1_1_projective.html#b2b98c6eb23ad3bf97a8129fe2bbdc4f" title="...and are not equal otherwise">operator !=</a>(<span class="keyword">const</span> <a class="code" href="classe2c2_1_1_projective.html" title="Class skeleton for projective points on Edwards Curves.">Projective</a>&amp; that)<span class="keyword"> const </span>{
<a name="l00251"></a>00251             <span class="keywordflow">return</span> !(*<span class="keyword">this</span> == that);
<a name="l00252"></a>00252         }
<a name="l00253"></a>00253 
<a name="l00255"></a><a class="code" href="classe2c2_1_1_projective.html#75de73ecec805a64abad01f85d843bfc">00255</a>         <a class="code" href="classe2c2_1_1_projective.html" title="Class skeleton for projective points on Edwards Curves.">Projective</a>&amp; <a class="code" href="classe2c2_1_1_projective.html#75de73ecec805a64abad01f85d843bfc" title="Assignment by addition; left to fleshed-out class specificities.">operator+=</a>(<span class="keyword">const</span> <a class="code" href="classe2c2_1_1_projective.html" title="Class skeleton for projective points on Edwards Curves.">Projective</a>&amp; that) {
<a name="l00256"></a>00256             <span class="keywordflow">if</span> (this-&gt;<a class="code" href="classe2c2_1_1_projective.html#551a78ebbaae16a790528a87ecfdd318" title="curve to which this point belongs">curve</a> != that.<a class="code" href="classe2c2_1_1_projective.html#551a78ebbaae16a790528a87ecfdd318" title="curve to which this point belongs">curve</a>)
<a name="l00257"></a>00257                 <span class="keywordflow">throw</span> <a class="code" href="classe2c2_1_1_different_curves_exception.html" title="Custom exception to be thrown when attempting to operate on points from different...">DifferentCurvesException</a>();
<a name="l00258"></a>00258 
<a name="l00259"></a>00259             *<span class="keyword">this</span> = <a class="code" href="namespacee2c2.html#daccb1ab1397161652ba57c0344fa24f" title="Projective addition for points on an odd curve.">proj_add</a>(*<span class="keyword">this</span>, that);
<a name="l00260"></a>00260             <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00261"></a>00261         }
<a name="l00262"></a>00262 
<a name="l00264"></a><a class="code" href="classe2c2_1_1_projective.html#5dc298ff75123994df3722f969805607">00264</a>         <a class="code" href="classe2c2_1_1_projective.html" title="Class skeleton for projective points on Edwards Curves.">Projective</a> <a class="code" href="classe2c2_1_1_projective.html#5dc298ff75123994df3722f969805607" title="Negation of a point; left to class specificities.">operator-</a>()<span class="keyword"> const </span>{
<a name="l00265"></a>00265             <span class="keywordflow">return</span> <a class="code" href="namespacee2c2.html#7b186074c3a5adf099e7e6ec4e26f396" title="Negation of an projective point on an odd curve.">proj_neg</a>(*<span class="keyword">this</span>);
<a name="l00266"></a>00266         }
<a name="l00267"></a>00267 
<a name="l00269"></a><a class="code" href="classe2c2_1_1_projective.html#3046d6af5b59056eb8f2a7febd1fecda">00269</a>         <a class="code" href="classe2c2_1_1_projective.html" title="Class skeleton for projective points on Edwards Curves.">Projective</a>&amp; <a class="code" href="classe2c2_1_1_projective.html#3046d6af5b59056eb8f2a7febd1fecda" title="Assignment by subtraction; makes use of += and -.">operator-=</a>(<span class="keyword">const</span> <a class="code" href="classe2c2_1_1_projective.html" title="Class skeleton for projective points on Edwards Curves.">Projective</a>&amp; that) {
<a name="l00270"></a>00270             <span class="keywordflow">return</span> *<span class="keyword">this</span> += -that;
<a name="l00271"></a>00271         }
<a name="l00272"></a>00272 
<a name="l00274"></a><a class="code" href="classe2c2_1_1_projective.html#bc4464af53cfc849f02ce5fa2d402c15">00274</a>         <a class="code" href="classe2c2_1_1_projective.html" title="Class skeleton for projective points on Edwards Curves.">Projective</a> <a class="code" href="classe2c2_1_1_projective.html#bc4464af53cfc849f02ce5fa2d402c15" title="Addition via +=.">operator+</a>(<span class="keyword">const</span> <a class="code" href="classe2c2_1_1_projective.html" title="Class skeleton for projective points on Edwards Curves.">Projective</a>&amp; that)<span class="keyword"> const </span>{
<a name="l00275"></a>00275             <span class="keywordflow">return</span> <a class="code" href="classe2c2_1_1_projective.html#252dda5ce288da82a1eb8b1856463100" title="Default constructor.">Projective</a>(*<span class="keyword">this</span>) += that;
<a name="l00276"></a>00276         }
<a name="l00277"></a>00277 
<a name="l00279"></a><a class="code" href="classe2c2_1_1_projective.html#e972b806732dd0d1fbee9912dd04651c">00279</a>         <a class="code" href="classe2c2_1_1_projective.html" title="Class skeleton for projective points on Edwards Curves.">Projective</a> <a class="code" href="classe2c2_1_1_projective.html#e972b806732dd0d1fbee9912dd04651c" title="Subtraction via -=.">operator-</a>(<span class="keyword">const</span> <a class="code" href="classe2c2_1_1_projective.html" title="Class skeleton for projective points on Edwards Curves.">Projective</a>&amp; that)<span class="keyword"> const </span>{
<a name="l00280"></a>00280             <span class="keywordflow">return</span> <a class="code" href="classe2c2_1_1_projective.html#252dda5ce288da82a1eb8b1856463100" title="Default constructor.">Projective</a>(*<span class="keyword">this</span>) -= that;
<a name="l00281"></a>00281         }
<a name="l00282"></a>00282 
<a name="l00284"></a><a class="code" href="classe2c2_1_1_projective.html#da0259e7e9bb0d7311e2f10b218067cd">00284</a>         <a class="code" href="classe2c2_1_1_projective.html" title="Class skeleton for projective points on Edwards Curves.">Projective</a> <a class="code" href="classe2c2_1_1_projective.html#da0259e7e9bb0d7311e2f10b218067cd" title="Point doubling; left to class specifics.">pointDouble</a>()<span class="keyword"> const </span>{
<a name="l00285"></a>00285             <span class="keywordflow">return</span> <a class="code" href="namespacee2c2.html#eb5f6cbd2e32fd1d6b02e4e436f266d0" title="Projective point doubling on odd curve.">proj_double</a>(*<span class="keyword">this</span>);
<a name="l00286"></a>00286         }
<a name="l00287"></a>00287 
<a name="l00289"></a><a class="code" href="classe2c2_1_1_projective.html#45b6f3609c7fb5cbfeacd622b2ae739f">00289</a>         <a class="code" href="classe2c2_1_1_projective.html" title="Class skeleton for projective points on Edwards Curves.">Projective</a> <a class="code" href="classe2c2_1_1_projective.html#45b6f3609c7fb5cbfeacd622b2ae739f" title="Montgomery Ladder for scalar multiplication.">montgomery</a>(<span class="keyword">const</span> NTL::ZZ&amp; k)<span class="keyword"> const </span>{
<a name="l00290"></a>00290             <span class="comment">// Work with positive scalars</span>
<a name="l00291"></a>00291             <span class="keywordflow">if</span> (k &lt; 0)
<a name="l00292"></a>00292                 <span class="keywordflow">return</span> (-(*<span class="keyword">this</span>)).<a class="code" href="classe2c2_1_1_projective.html#45b6f3609c7fb5cbfeacd622b2ae739f" title="Montgomery Ladder for scalar multiplication.">montgomery</a>(-k);
<a name="l00293"></a>00293 
<a name="l00294"></a>00294             <span class="comment">// Counteract Brumley &amp; Tuveri's timing attack</span>
<a name="l00295"></a>00295             NTL::ZZ kk = <a class="code" href="namespacee2c2.html#81b4cfe5fe88c655195bb82c9dffc4cc" title="This function counteracts the timing attack outlined in Brumley &amp;amp; Tuveri&amp;#39;s...">counterBTTiming</a>(k, <a class="code" href="classe2c2_1_1_projective.html#551a78ebbaae16a790528a87ecfdd318" title="curve to which this point belongs">curve</a>.<a class="code" href="classe2c2_1_1_curve.html#1468b9ede88d740fa8aac06130929d0b" title="Number of rational points on curve over field.">cardinality</a>());
<a name="l00296"></a>00296 
<a name="l00297"></a>00297             <a class="code" href="classe2c2_1_1_projective.html" title="Class skeleton for projective points on Edwards Curves.">Projective</a> aTmp(<a class="code" href="classe2c2_1_1_projective.html#551a78ebbaae16a790528a87ecfdd318" title="curve to which this point belongs">curve</a>);  <span class="comment">// identity element</span>
<a name="l00298"></a>00298             <a class="code" href="classe2c2_1_1_projective.html" title="Class skeleton for projective points on Edwards Curves.">Projective</a> bTmp(*<span class="keyword">this</span>);
<a name="l00299"></a>00299             <span class="keywordflow">for</span> (<span class="keyword">auto</span> i = NumBits(kk) - 1; i &gt;= 0; i--) {
<a name="l00300"></a>00300                 <span class="keywordflow">if</span> (bit(k, i)) {
<a name="l00301"></a>00301                     aTmp += bTmp;
<a name="l00302"></a>00302                     bTmp = bTmp.<a class="code" href="classe2c2_1_1_projective.html#da0259e7e9bb0d7311e2f10b218067cd" title="Point doubling; left to class specifics.">pointDouble</a>();
<a name="l00303"></a>00303                 } <span class="keywordflow">else</span> {
<a name="l00304"></a>00304                     bTmp += aTmp;
<a name="l00305"></a>00305                     aTmp = aTmp.<a class="code" href="classe2c2_1_1_projective.html#da0259e7e9bb0d7311e2f10b218067cd" title="Point doubling; left to class specifics.">pointDouble</a>();
<a name="l00306"></a>00306                 }
<a name="l00307"></a>00307             }
<a name="l00308"></a>00308             <span class="keywordflow">return</span> aTmp;
<a name="l00309"></a>00309         }
<a name="l00310"></a>00310 
<a name="l00312"></a><a class="code" href="classe2c2_1_1_projective.html#5b6c847ce68cece53d0751e419ca563f">00312</a>         <a class="code" href="classe2c2_1_1_projective.html" title="Class skeleton for projective points on Edwards Curves.">Projective</a>&amp; <a class="code" href="classe2c2_1_1_projective.html#5b6c847ce68cece53d0751e419ca563f" title="Assignment by scalar multiplication (using Montgomery Ladder).">operator*=</a>(<span class="keyword">const</span> NTL::ZZ&amp; k) {
<a name="l00313"></a>00313             <span class="keywordflow">return</span> *<span class="keyword">this</span> = <a class="code" href="classe2c2_1_1_projective.html#45b6f3609c7fb5cbfeacd622b2ae739f" title="Montgomery Ladder for scalar multiplication.">montgomery</a>(k);
<a name="l00314"></a>00314         }
<a name="l00315"></a>00315 
<a name="l00317"></a>00317         <span class="keyword">template</span> &lt;<span class="keyword">class</span> N&gt;
<a name="l00318"></a><a class="code" href="classe2c2_1_1_projective.html#9b8e81a53ab63eeca082d6589744ef05">00318</a>         <a class="code" href="classe2c2_1_1_projective.html" title="Class skeleton for projective points on Edwards Curves.">Projective</a>&amp; <a class="code" href="classe2c2_1_1_projective.html#9b8e81a53ab63eeca082d6589744ef05" title="Assignment by scalar multiplication (using Montgomery Ladder).">operator*=</a>(<span class="keyword">const</span> N&amp; k) {
<a name="l00319"></a>00319             <span class="keywordflow">return</span> *<span class="keyword">this</span> = <a class="code" href="classe2c2_1_1_projective.html#45b6f3609c7fb5cbfeacd622b2ae739f" title="Montgomery Ladder for scalar multiplication.">montgomery</a>(NTL::to_ZZ(k));
<a name="l00320"></a>00320         }
<a name="l00321"></a>00321 
<a name="l00324"></a><a class="code" href="classe2c2_1_1_projective.html#f8121da801885608efcc98f59abbc916">00324</a>         <span class="keyword">friend</span> <a class="code" href="classe2c2_1_1_projective.html" title="Class skeleton for projective points on Edwards Curves.">Projective</a> <a class="code" href="classe2c2_1_1_projective.html#f8121da801885608efcc98f59abbc916">operator*</a>(<span class="keyword">const</span> NTL::ZZ&amp; k,
<a name="l00325"></a>00325             <span class="keyword">const</span> <a class="code" href="classe2c2_1_1_projective.html" title="Class skeleton for projective points on Edwards Curves.">Projective</a>&amp; point) {
<a name="l00326"></a>00326             <span class="keywordflow">return</span> <a class="code" href="classe2c2_1_1_projective.html#252dda5ce288da82a1eb8b1856463100" title="Default constructor.">Projective</a>(point) *= k;
<a name="l00327"></a>00327         }
<a name="l00328"></a>00328 
<a name="l00331"></a>00331         <span class="keyword">template</span> &lt;<span class="keyword">class</span> N&gt;
<a name="l00332"></a><a class="code" href="classe2c2_1_1_projective.html#0076a26beabadfe3ec1fcf1a10ab9777">00332</a>         <span class="keyword">friend</span> <a class="code" href="classe2c2_1_1_projective.html" title="Class skeleton for projective points on Edwards Curves.">Projective</a> <a class="code" href="classe2c2_1_1_projective.html#0076a26beabadfe3ec1fcf1a10ab9777">operator*</a>(<span class="keyword">const</span> N&amp; k, <span class="keyword">const</span> <a class="code" href="classe2c2_1_1_projective.html" title="Class skeleton for projective points on Edwards Curves.">Projective</a>&amp; point) {
<a name="l00333"></a>00333             <span class="keywordflow">return</span> <a class="code" href="classe2c2_1_1_projective.html#252dda5ce288da82a1eb8b1856463100" title="Default constructor.">Projective</a>(point) *= NTL::to_ZZ(k);
<a name="l00334"></a>00334         }
<a name="l00335"></a>00335 
<a name="l00336"></a>00336 
<a name="l00338"></a><a class="code" href="classe2c2_1_1_projective.html#8547ec675b24e92ed20532d217d04757">00338</a>         <span class="keyword">friend</span> std::ostream&amp; <a class="code" href="classe2c2_1_1_projective.html#8547ec675b24e92ed20532d217d04757" title="Output.">operator&lt;&lt;</a>(std::ostream&amp; out,
<a name="l00339"></a>00339                 <span class="keyword">const</span> <a class="code" href="classe2c2_1_1_projective.html" title="Class skeleton for projective points on Edwards Curves.">Projective</a>&amp; point) {
<a name="l00340"></a>00340             <a class="code" href="classe2c2_1_1_projective.html" title="Class skeleton for projective points on Edwards Curves.">Projective</a> tmp = point.<a class="code" href="classe2c2_1_1_projective.html#feb1a0b17cfc95fd1676ec8c09b99e5e" title="Equivalence class representative: z = 1.">equivalenceClassRep</a>();
<a name="l00341"></a>00341             <span class="keywordflow">return</span> (out &lt;&lt; <span class="stringliteral">"("</span> &lt;&lt; tmp.<a class="code" href="classe2c2_1_1_projective.html#4cf72186f8bd222ffcb6d80a3852043f" title="x-coordinate">x</a> &lt;&lt; <span class="stringliteral">" : "</span> &lt;&lt; tmp.<a class="code" href="classe2c2_1_1_projective.html#77b28886ad808c12a1889476c5e546e2" title="y-coordinate">y</a> &lt;&lt; <span class="stringliteral">" : "</span> &lt;&lt; tmp.<a class="code" href="classe2c2_1_1_projective.html#3f29811c0d05e61d14ff5fae2b0aca6a" title="z-coordinate">z</a> &lt;&lt;
<a name="l00342"></a>00342                     <span class="stringliteral">")"</span> );
<a name="l00343"></a>00343         }
<a name="l00344"></a>00344 
<a name="l00345"></a>00345     };
<a name="l00346"></a>00346 
<a name="l00347"></a>00347 
<a name="l00348"></a>00348     <span class="comment">//------- Affine Specialization Functions -------//</span>
<a name="l00349"></a>00349 
<a name="l00357"></a>00357     <span class="keyword">using</span> OddAff = Affine&lt;NTL::ZZ_pE, OddCurve&gt;;
<a name="l00358"></a>00358 
<a name="l00363"></a><a class="code" href="namespacee2c2.html#6be24594df790c851dd9a353717c6ade">00363</a>     <span class="keyword">inline</span> OddAff <a class="code" href="namespacee2c2.html#6be24594df790c851dd9a353717c6ade" title="Affine neutral element on odd curve.">aff_id</a>(<span class="keyword">const</span> OddCurve&amp; curve) {
<a name="l00364"></a>00364         <span class="keywordflow">return</span> OddAff(NTL::ZZ_pE::zero(), curve.c, curve);
<a name="l00365"></a>00365     }
<a name="l00366"></a>00366 
<a name="l00371"></a><a class="code" href="namespacee2c2.html#bced6b0a7b0bb724367daccb960bd373">00371</a>     <span class="keyword">inline</span> OddAff <a class="code" href="namespacee2c2.html#bced6b0a7b0bb724367daccb960bd373" title="Affine addition for points on an odd curve.">aff_add</a>(<span class="keyword">const</span> OddAff&amp; a1, <span class="keyword">const</span> OddAff&amp; a2) {
<a name="l00372"></a>00372         NTL::ZZ_pE w, num_x, num_y, den_x, den_y;
<a name="l00373"></a>00373         w = a1.curve.d * a1.x * a2.x * a1.y * a2.y;
<a name="l00374"></a>00374         num_x = a1.x * a2.y + a1.y * a2.x;
<a name="l00375"></a>00375         num_y = a1.y * a2.y - a1.x * a2.x;
<a name="l00376"></a>00376         den_x = a1.curve.c * (1 + w);
<a name="l00377"></a>00377         den_y = a1.curve.c * (1 - w);
<a name="l00378"></a>00378 
<a name="l00379"></a>00379         <span class="keywordflow">return</span> OddAff(num_x / den_x,
<a name="l00380"></a>00380                       num_y / den_y,
<a name="l00381"></a>00381                       a1.curve);
<a name="l00382"></a>00382     }
<a name="l00383"></a>00383 
<a name="l00388"></a><a class="code" href="namespacee2c2.html#7af88d3a6e3c922faa355b316c42d673">00388</a>     <span class="keyword">inline</span> OddAff <a class="code" href="namespacee2c2.html#7af88d3a6e3c922faa355b316c42d673" title="Negation of an affine point on an odd curve.">aff_neg</a>(<span class="keyword">const</span> OddAff&amp; a) {
<a name="l00389"></a>00389         <span class="keywordflow">return</span> OddAff(-a.x, a.y, a.curve);
<a name="l00390"></a>00390     }
<a name="l00391"></a>00391 
<a name="l00396"></a><a class="code" href="namespacee2c2.html#513a9ef3d910317b835b1008a81d9400">00396</a>     <span class="keyword">inline</span> OddAff <a class="code" href="namespacee2c2.html#513a9ef3d910317b835b1008a81d9400" title="Affine point doubling on odd curve.">aff_double</a>(<span class="keyword">const</span> OddAff&amp; a) {
<a name="l00397"></a>00397         <span class="keyword">auto</span> xx = NTL::sqr(a.x);
<a name="l00398"></a>00398         <span class="keyword">auto</span> yy = NTL::sqr(a.y);
<a name="l00399"></a>00399         <span class="keyword">auto</span> num_x = 2 * a.x * a.y * a.curve.c;
<a name="l00400"></a>00400         <span class="keyword">auto</span> num_y = (yy - xx) * a.curve.c;
<a name="l00401"></a>00401         <span class="keyword">auto</span> den_x = xx + yy;
<a name="l00402"></a>00402         <span class="keyword">auto</span> den_y = 2 * NTL::sqr(a.curve.c) - (xx + yy);
<a name="l00403"></a>00403 
<a name="l00404"></a>00404         <span class="keywordflow">return</span> OddAff(num_x / den_x, num_y / den_y, a.curve);
<a name="l00405"></a>00405     }
<a name="l00406"></a>00406 
<a name="l00407"></a>00407 
<a name="l00415"></a>00415     <span class="keyword">using</span> BinaryAff = Affine&lt;NTL::GF2E, BinaryCurve&gt;;
<a name="l00416"></a>00416 
<a name="l00421"></a><a class="code" href="namespacee2c2.html#64217da64f580c1f1d6d081d367bb9ef">00421</a>     <span class="keyword">inline</span> BinaryAff <a class="code" href="namespacee2c2.html#6be24594df790c851dd9a353717c6ade" title="Affine neutral element on odd curve.">aff_id</a>(<span class="keyword">const</span> BinaryCurve&amp; curve) {
<a name="l00422"></a>00422         <span class="keywordflow">return</span> BinaryAff(NTL::GF2E::zero(), NTL::GF2E::zero(), curve);
<a name="l00423"></a>00423     }
<a name="l00424"></a>00424 
<a name="l00429"></a><a class="code" href="namespacee2c2.html#e3aab4bf2e21c72b622d7517f220388b">00429</a>     <span class="keyword">inline</span> BinaryAff <a class="code" href="namespacee2c2.html#bced6b0a7b0bb724367daccb960bd373" title="Affine addition for points on an odd curve.">aff_add</a>(<span class="keyword">const</span> BinaryAff&amp; a1, <span class="keyword">const</span> BinaryAff&amp; a2) {
<a name="l00430"></a>00430         <span class="keyword">auto</span> w1 = a1.x + a1.y;
<a name="l00431"></a>00431         <span class="keyword">auto</span> w2 = a2.x + a2.y;
<a name="l00432"></a>00432         <span class="keyword">auto</span> a = NTL::sqr(a1.x) + a1.x;
<a name="l00433"></a>00433         <span class="keyword">auto</span> b = NTL::sqr(a1.y) + a1.y;
<a name="l00434"></a>00434         <span class="keyword">auto</span> c = a1.curve.d * w1 * w2;
<a name="l00435"></a>00435         <span class="keyword">auto</span> d = a2.x * a2.y;
<a name="l00436"></a>00436 
<a name="l00437"></a>00437         <span class="keywordflow">return</span> BinaryAff(
<a name="l00438"></a>00438                 a1.y + (c + a1.curve.c * (w1 + a2.x) + a * (d + a2.x)) /
<a name="l00439"></a>00439                     (a1.curve.c + a*w2),
<a name="l00440"></a>00440                 a1.x + (c + a1.curve.c * (w1 + a2.y) + b * (d + a2.y)) /
<a name="l00441"></a>00441                     (a1.curve.c + b * w2),
<a name="l00442"></a>00442                 a1.curve);
<a name="l00443"></a>00443     }
<a name="l00444"></a>00444 
<a name="l00449"></a><a class="code" href="namespacee2c2.html#10e2c7a3a060385a35b528b9e0afb765">00449</a>     <span class="keyword">inline</span> BinaryAff <a class="code" href="namespacee2c2.html#7af88d3a6e3c922faa355b316c42d673" title="Negation of an affine point on an odd curve.">aff_neg</a>(<span class="keyword">const</span> BinaryAff&amp; a) {
<a name="l00450"></a>00450         <span class="keywordflow">return</span> BinaryAff(a.y, a.x, a.curve);
<a name="l00451"></a>00451     }
<a name="l00452"></a>00452 
<a name="l00457"></a><a class="code" href="namespacee2c2.html#2a94cd1c641ab54ca0de1725e51c1638">00457</a>     <span class="keyword">inline</span> BinaryAff <a class="code" href="namespacee2c2.html#513a9ef3d910317b835b1008a81d9400" title="Affine point doubling on odd curve.">aff_double</a>(<span class="keyword">const</span> BinaryAff&amp; a) {
<a name="l00458"></a>00458         <span class="keyword">auto</span> aa = NTL::sqr(a.x);
<a name="l00459"></a>00459         <span class="keyword">auto</span> b = NTL::sqr(aa);
<a name="l00460"></a>00460         <span class="keyword">auto</span> c = NTL::sqr(a.y);
<a name="l00461"></a>00461         <span class="keyword">auto</span> d = NTL::sqr(c);
<a name="l00462"></a>00462         <span class="keyword">auto</span> f = a.curve.c;
<a name="l00463"></a>00463         <span class="keyword">auto</span> g = (a.curve.d / a.curve.c) * (b + d);
<a name="l00464"></a>00464         <span class="keyword">auto</span> j = aa + c;
<a name="l00465"></a>00465         <span class="keyword">auto</span> k = g + a.curve.d * j;
<a name="l00466"></a>00466         <span class="keyword">auto</span> z = f + j + g;
<a name="l00467"></a>00467 
<a name="l00468"></a>00468         <span class="keywordflow">return</span> BinaryAff((k + aa + d) / z,
<a name="l00469"></a>00469                          (k + c + b) / z,
<a name="l00470"></a>00470                          a.curve);
<a name="l00471"></a>00471     }
<a name="l00472"></a>00472 
<a name="l00478"></a><a class="code" href="namespacee2c2.html#71c6b9ebecec41d8428659f32247f0fd">00478</a>     <span class="keyword">inline</span> BinaryAff <a class="code" href="namespacee2c2.html#71c6b9ebecec41d8428659f32247f0fd" title="Birational Map from Weierstrass curve to Binary Edwards curve.">birMapAff</a>(<span class="keyword">const</span> NTL::GF2E&amp; u, <span class="keyword">const</span> NTL::GF2E&amp; v,
<a name="l00479"></a>00479             <span class="keyword">const</span> NTL::GF2E&amp; a2, <span class="keyword">const</span> BinaryCurve&amp; curve) {
<a name="l00480"></a>00480         NTL::GF2E x, y;
<a name="l00481"></a>00481         <a class="code" href="namespacee2c2.html#0967198afb8317a10331f965b5f70b33" title="MOL&amp;#39;s birational map from Weierstrass curve to Affine Binary Edwards.">mol_bm_aff</a>(x, y, u, v, NTL::GF2E::degree(), curve.c, curve.d, a2);
<a name="l00482"></a>00482         <span class="keywordflow">return</span> BinaryAff(x, y, curve);
<a name="l00483"></a>00483     }
<a name="l00484"></a>00484 
<a name="l00485"></a>00485 
<a name="l00493"></a>00493     <span class="keyword">using</span> TwistedAff = Affine&lt;NTL::ZZ_pE, TwistedCurve&gt;;
<a name="l00494"></a>00494 
<a name="l00499"></a><a class="code" href="namespacee2c2.html#84dc98a56552b00459fe534ceda2fdab">00499</a>     <span class="keyword">inline</span> TwistedAff <a class="code" href="namespacee2c2.html#6be24594df790c851dd9a353717c6ade" title="Affine neutral element on odd curve.">aff_id</a>(<span class="keyword">const</span> TwistedCurve&amp; curve) {
<a name="l00500"></a>00500         <span class="keywordflow">return</span> TwistedAff(NTL::ZZ_pE::zero(), NTL::to_ZZ_pE(1), curve);
<a name="l00501"></a>00501     }
<a name="l00502"></a>00502 
<a name="l00507"></a><a class="code" href="namespacee2c2.html#6810e3d7732b367b2d10bc9708d5c0f1">00507</a>     <span class="keyword">inline</span> TwistedAff <a class="code" href="namespacee2c2.html#bced6b0a7b0bb724367daccb960bd373" title="Affine addition for points on an odd curve.">aff_add</a>(<span class="keyword">const</span> TwistedAff&amp; a1, <span class="keyword">const</span> TwistedAff&amp; a2) {
<a name="l00508"></a>00508         <span class="keyword">auto</span> w = a1.curve.d * a1.x * a2.x * a1.y * a2.y;
<a name="l00509"></a>00509         <span class="keyword">auto</span> num_x = a1.x * a2.y + a1.y * a2.x;
<a name="l00510"></a>00510         <span class="keyword">auto</span> num_y = a1.y * a2.y - a1.curve.d * a1.x * a2.x;
<a name="l00511"></a>00511         <span class="keyword">auto</span> den_x = 1 + w;
<a name="l00512"></a>00512         <span class="keyword">auto</span> den_y = 1 - w;
<a name="l00513"></a>00513 
<a name="l00514"></a>00514         <span class="keywordflow">return</span> TwistedAff(num_x / den_x, num_y / den_y, a1.curve);
<a name="l00515"></a>00515     }
<a name="l00516"></a>00516 
<a name="l00521"></a><a class="code" href="namespacee2c2.html#9f1f25fd6331adc57d73f73c86f8cb0c">00521</a>     <span class="keyword">inline</span> TwistedAff <a class="code" href="namespacee2c2.html#7af88d3a6e3c922faa355b316c42d673" title="Negation of an affine point on an odd curve.">aff_neg</a>(<span class="keyword">const</span> TwistedAff&amp; a) {
<a name="l00522"></a>00522         <span class="keywordflow">return</span> TwistedAff(-a.x, a.y, a.curve);
<a name="l00523"></a>00523     }
<a name="l00524"></a>00524 
<a name="l00529"></a><a class="code" href="namespacee2c2.html#09657b42fbf11673bbdfe33447985205">00529</a>     <span class="keyword">inline</span> TwistedAff <a class="code" href="namespacee2c2.html#513a9ef3d910317b835b1008a81d9400" title="Affine point doubling on odd curve.">aff_double</a>(<span class="keyword">const</span> TwistedAff&amp; a) {
<a name="l00530"></a>00530         <span class="keyword">auto</span> b = NTL::sqr(a.x + a.y);
<a name="l00531"></a>00531         <span class="keyword">auto</span> c = NTL::sqr(a.x);
<a name="l00532"></a>00532         <span class="keyword">auto</span> d = NTL::sqr(a.y);
<a name="l00533"></a>00533         <span class="keyword">auto</span> e = a.curve.c * c;
<a name="l00534"></a>00534         <span class="keyword">auto</span> f = e + d;
<a name="l00535"></a>00535         <span class="keyword">auto</span> j = f - 2;
<a name="l00536"></a>00536         <span class="keyword">auto</span> z = f * j;
<a name="l00537"></a>00537 
<a name="l00538"></a>00538         <span class="keywordflow">return</span> TwistedAff(((b - c - d) * j) / z,
<a name="l00539"></a>00539                           (f * (e - d)) / z,
<a name="l00540"></a>00540                           a.curve);
<a name="l00541"></a>00541     }
<a name="l00542"></a>00542 
<a name="l00543"></a>00543 
<a name="l00544"></a>00544     <span class="comment">//------- Projective Specialization Functions -------//</span>
<a name="l00545"></a>00545 
<a name="l00553"></a>00553     <span class="keyword">using</span> OddProj = Projective&lt;NTL::ZZ_pE, OddCurve&gt;;
<a name="l00554"></a>00554 
<a name="l00559"></a><a class="code" href="namespacee2c2.html#9aaff940aad3bd38fe3e141added00c7">00559</a>     <span class="keyword">inline</span> OddProj <a class="code" href="namespacee2c2.html#9aaff940aad3bd38fe3e141added00c7" title="Projective neutral element on odd curve.">proj_id</a>(<span class="keyword">const</span> OddCurve&amp; curve) {
<a name="l00560"></a>00560         <span class="keywordflow">return</span> OddProj(NTL::ZZ_pE::zero(),
<a name="l00561"></a>00561                 curve.c,
<a name="l00562"></a>00562                 NTL::to_ZZ_pE(1),
<a name="l00563"></a>00563                 curve);
<a name="l00564"></a>00564     }
<a name="l00565"></a>00565 
<a name="l00570"></a><a class="code" href="namespacee2c2.html#daccb1ab1397161652ba57c0344fa24f">00570</a>     <span class="keyword">inline</span> OddProj <a class="code" href="namespacee2c2.html#daccb1ab1397161652ba57c0344fa24f" title="Projective addition for points on an odd curve.">proj_add</a>(<span class="keyword">const</span> OddProj&amp; p1, <span class="keyword">const</span> OddProj&amp; p2) {
<a name="l00571"></a>00571         <span class="comment">// From Bernstein &amp; Lange, "Faster Addition and Doubling on Elliptic</span>
<a name="l00572"></a>00572         <span class="comment">// Curves"</span>
<a name="l00573"></a>00573         <span class="keyword">auto</span> a = p1.z * p2.z;
<a name="l00574"></a>00574         <span class="keyword">auto</span> b = NTL::sqr(a);
<a name="l00575"></a>00575         <span class="keyword">auto</span> c = p1.x * p2.x;
<a name="l00576"></a>00576         <span class="keyword">auto</span> d = p1.y * p2.y;
<a name="l00577"></a>00577         <span class="keyword">auto</span> e = p1.curve.d * c * d;
<a name="l00578"></a>00578         <span class="keyword">auto</span> f = b - e;
<a name="l00579"></a>00579         <span class="keyword">auto</span> g = b + e;
<a name="l00580"></a>00580         <span class="keywordflow">return</span> OddProj(a * f * ((p1.x + p1.y) * (p2.x + p2.y) - c - d),
<a name="l00581"></a>00581                        a * g * (d - c),
<a name="l00582"></a>00582                        p1.curve.c * f * g,
<a name="l00583"></a>00583                        p1.curve);
<a name="l00584"></a>00584     }
<a name="l00585"></a>00585 
<a name="l00590"></a><a class="code" href="namespacee2c2.html#7b186074c3a5adf099e7e6ec4e26f396">00590</a>     <span class="keyword">inline</span> OddProj <a class="code" href="namespacee2c2.html#7b186074c3a5adf099e7e6ec4e26f396" title="Negation of an projective point on an odd curve.">proj_neg</a>(<span class="keyword">const</span> OddProj&amp; p) {
<a name="l00591"></a>00591         <span class="keywordflow">return</span> OddProj(-p.x, p.y, p.z, p.curve);
<a name="l00592"></a>00592     }
<a name="l00593"></a>00593 
<a name="l00598"></a><a class="code" href="namespacee2c2.html#eb5f6cbd2e32fd1d6b02e4e436f266d0">00598</a>     <span class="keyword">inline</span> OddProj <a class="code" href="namespacee2c2.html#eb5f6cbd2e32fd1d6b02e4e436f266d0" title="Projective point doubling on odd curve.">proj_double</a>(<span class="keyword">const</span> OddProj&amp; p) {
<a name="l00601"></a>00601         <span class="keyword">auto</span> b = NTL::sqr(p.x + p.y);
<a name="l00602"></a>00602         <span class="keyword">auto</span> c = NTL::sqr(p.x);
<a name="l00603"></a>00603         <span class="keyword">auto</span> d = NTL::sqr(p.y);
<a name="l00604"></a>00604         <span class="keyword">auto</span> e = c + d;
<a name="l00605"></a>00605         <span class="keyword">auto</span> h = NTL::sqr(p.curve.c * p.z);
<a name="l00606"></a>00606         <span class="keyword">auto</span> j = e - 2 * h;
<a name="l00607"></a>00607         <span class="keywordflow">return</span> OddProj(p.curve.c * (b - e) * j,
<a name="l00608"></a>00608                        p.curve.c * e * (c - d),
<a name="l00609"></a>00609                        e * j,
<a name="l00610"></a>00610                        p.curve);
<a name="l00611"></a>00611     }
<a name="l00612"></a>00612 
<a name="l00613"></a>00613 
<a name="l00621"></a>00621     <span class="keyword">using</span> BinaryProj = Projective&lt;NTL::GF2E, BinaryCurve&gt;;
<a name="l00622"></a>00622 
<a name="l00627"></a><a class="code" href="namespacee2c2.html#1d5f305e6c714884242b6123bb2cb7ab">00627</a>     <span class="keyword">inline</span> BinaryProj <a class="code" href="namespacee2c2.html#9aaff940aad3bd38fe3e141added00c7" title="Projective neutral element on odd curve.">proj_id</a>(<span class="keyword">const</span> BinaryCurve&amp; curve) {
<a name="l00628"></a>00628         <span class="keywordflow">return</span> BinaryProj(NTL::GF2E::zero(),
<a name="l00629"></a>00629                           NTL::GF2E::zero(),
<a name="l00630"></a>00630                           NTL::to_GF2E(1),
<a name="l00631"></a>00631                           curve);
<a name="l00632"></a>00632     }
<a name="l00633"></a>00633 
<a name="l00638"></a><a class="code" href="namespacee2c2.html#9cc9801b0188ba8371cf627438748271">00638</a>     <span class="keyword">inline</span> BinaryProj <a class="code" href="namespacee2c2.html#daccb1ab1397161652ba57c0344fa24f" title="Projective addition for points on an odd curve.">proj_add</a>(<span class="keyword">const</span> BinaryProj&amp; p1, <span class="keyword">const</span> BinaryProj&amp; p2) {
<a name="l00640"></a>00640         <span class="keyword">auto</span> w1 = p1.x + p1.y;
<a name="l00641"></a>00641         <span class="keyword">auto</span> w2 = p2.x + p2.y;
<a name="l00642"></a>00642         <span class="keyword">auto</span> a = p1.x * (p1.x + p1.z);
<a name="l00643"></a>00643         <span class="keyword">auto</span> b = p1.y * (p1.y + p1.z);
<a name="l00644"></a>00644         <span class="keyword">auto</span> c = p1.z * p2.z;
<a name="l00645"></a>00645         <span class="keyword">auto</span> d = w2 * p2.z;
<a name="l00646"></a>00646         <span class="keyword">auto</span> e = p1.curve.c * NTL::sqr(c);
<a name="l00647"></a>00647         <span class="keyword">auto</span> h = (p1.curve.c * p2.z + p1.curve.d * w2) * w1 * c;
<a name="l00648"></a>00648         <span class="keyword">auto</span> i = p1.curve.c * c * p1.z;
<a name="l00649"></a>00649         <span class="keyword">auto</span> u = e + a * d;
<a name="l00650"></a>00650         <span class="keyword">auto</span> v = e + b * d;
<a name="l00651"></a>00651         <span class="keyword">auto</span> s = u * v;
<a name="l00652"></a>00652         <span class="keywordflow">return</span> BinaryProj(
<a name="l00653"></a>00653                 s * p1.y + (h + p2.x * (i + a * (p2.y + p2.z))) * v * p1.z,
<a name="l00654"></a>00654                 s * p1.x + (h + p2.y * (i + b * (p2.x + p2.z))) * u * p1.z,
<a name="l00655"></a>00655                 s * p1.z,
<a name="l00656"></a>00656                 p1.curve);
<a name="l00657"></a>00657     }
<a name="l00658"></a>00658 
<a name="l00663"></a><a class="code" href="namespacee2c2.html#2e53a27aad57b3576f7b371fa5c0e663">00663</a>     <span class="keyword">inline</span> BinaryProj <a class="code" href="namespacee2c2.html#7b186074c3a5adf099e7e6ec4e26f396" title="Negation of an projective point on an odd curve.">proj_neg</a>(<span class="keyword">const</span> BinaryProj&amp; p) {
<a name="l00664"></a>00664         <span class="keywordflow">return</span> BinaryProj(p.y, p.x, p.z, p.curve);
<a name="l00665"></a>00665     }
<a name="l00666"></a>00666 
<a name="l00671"></a><a class="code" href="namespacee2c2.html#60ea5697e5e60fd664febc286fd7b6ad">00671</a>     <span class="keyword">inline</span> BinaryProj <a class="code" href="namespacee2c2.html#eb5f6cbd2e32fd1d6b02e4e436f266d0" title="Projective point doubling on odd curve.">proj_double</a>(<span class="keyword">const</span> BinaryProj&amp; p) {
<a name="l00673"></a>00673         <span class="keyword">auto</span> a = NTL::sqr(p.x);
<a name="l00674"></a>00674         <span class="keyword">auto</span> b = NTL::sqr(a);
<a name="l00675"></a>00675         <span class="keyword">auto</span> c = NTL::sqr(p.y);
<a name="l00676"></a>00676         <span class="keyword">auto</span> d = NTL::sqr(c);
<a name="l00677"></a>00677         <span class="keyword">auto</span> e = NTL::sqr(p.z);
<a name="l00678"></a>00678         <span class="keyword">auto</span> f = p.curve.c * NTL::sqr(e);
<a name="l00679"></a>00679         <span class="keyword">auto</span> g = (p.curve.d / p.curve.c) * (b + d);
<a name="l00680"></a>00680         <span class="keyword">auto</span> h = a * e;
<a name="l00681"></a>00681         <span class="keyword">auto</span> i = c * e;
<a name="l00682"></a>00682         <span class="keyword">auto</span> j = h + i;
<a name="l00683"></a>00683         <span class="keyword">auto</span> k = g + p.curve.d * j;
<a name="l00684"></a>00684         <span class="keywordflow">return</span> BinaryProj(k + h + d, k + i + b, f + j + g, p.curve);
<a name="l00685"></a>00685     }
<a name="l00686"></a>00686 
<a name="l00692"></a><a class="code" href="namespacee2c2.html#7ba2d431ad27afc8311a081f12d4185f">00692</a>     <span class="keyword">inline</span> BinaryProj <a class="code" href="namespacee2c2.html#7ba2d431ad27afc8311a081f12d4185f" title="Birational Map from Weierstrass curve to Binary Edwards curve.">birMapProj</a>(<span class="keyword">const</span> NTL::GF2E&amp; u, <span class="keyword">const</span> NTL::GF2E&amp; v,
<a name="l00693"></a>00693             <span class="keyword">const</span> NTL::GF2E&amp; a2, <span class="keyword">const</span> BinaryCurve&amp; curve) {
<a name="l00694"></a>00694         NTL::GF2E x, y, z;
<a name="l00695"></a>00695         <a class="code" href="namespacee2c2.html#78ac67306ce0eba1c0c4dbdc8e780917">mol_bm_proj</a>(x, y, z, u, v, NTL::GF2E::degree(), curve.c, curve.d,  a2);
<a name="l00696"></a>00696         <span class="keywordflow">return</span> BinaryProj(x, y, z, curve);
<a name="l00697"></a>00697     }
<a name="l00698"></a>00698 
<a name="l00699"></a>00699 
<a name="l00707"></a>00707     <span class="keyword">using</span> TwistedProj = Projective&lt;NTL::ZZ_pE, TwistedCurve&gt;;
<a name="l00708"></a>00708 
<a name="l00713"></a><a class="code" href="namespacee2c2.html#ac4567eb6e0eff466de8b0b046b6b7ba">00713</a>     <span class="keyword">inline</span> TwistedProj <a class="code" href="namespacee2c2.html#9aaff940aad3bd38fe3e141added00c7" title="Projective neutral element on odd curve.">proj_id</a>(<span class="keyword">const</span> TwistedCurve&amp; curve) {
<a name="l00714"></a>00714         <span class="keywordflow">return</span> TwistedProj(NTL::ZZ_pE::zero(),
<a name="l00715"></a>00715                            NTL::to_ZZ_pE(1),
<a name="l00716"></a>00716                            NTL::to_ZZ_pE(1),
<a name="l00717"></a>00717                            curve);
<a name="l00718"></a>00718     }
<a name="l00719"></a>00719 
<a name="l00724"></a><a class="code" href="namespacee2c2.html#7663fdc86464b6ea324ac977a4e022d9">00724</a>     <span class="keyword">inline</span> TwistedProj <a class="code" href="namespacee2c2.html#daccb1ab1397161652ba57c0344fa24f" title="Projective addition for points on an odd curve.">proj_add</a>(<span class="keyword">const</span> TwistedProj&amp; p1, <span class="keyword">const</span> TwistedProj&amp; p2) {
<a name="l00727"></a>00727         <span class="keyword">auto</span> a = p1.z * p2.z;
<a name="l00728"></a>00728         <span class="keyword">auto</span> b = NTL::sqr(a);
<a name="l00729"></a>00729         <span class="keyword">auto</span> c = p1.x * p2.x;
<a name="l00730"></a>00730         <span class="keyword">auto</span> d = p1.y * p2.y;
<a name="l00731"></a>00731         <span class="keyword">auto</span> e = p1.curve.d * c * d;
<a name="l00732"></a>00732         <span class="keyword">auto</span> f = b - e;
<a name="l00733"></a>00733         <span class="keyword">auto</span> g = b + e;
<a name="l00734"></a>00734         <span class="keywordflow">return</span> TwistedProj(a * f * ((p1.x + p1.y) * (p2.x + p2.y) - c - d),
<a name="l00735"></a>00735                            a * g * (d - p1.curve.c * c),
<a name="l00736"></a>00736                            f * g,
<a name="l00737"></a>00737                            p1.curve);
<a name="l00738"></a>00738     }
<a name="l00739"></a>00739 
<a name="l00744"></a><a class="code" href="namespacee2c2.html#9672f291f73ba4b2bba3d2b923ef4a31">00744</a>     <span class="keyword">inline</span> TwistedProj <a class="code" href="namespacee2c2.html#7b186074c3a5adf099e7e6ec4e26f396" title="Negation of an projective point on an odd curve.">proj_neg</a>(<span class="keyword">const</span> TwistedProj&amp; p) {
<a name="l00745"></a>00745         <span class="keywordflow">return</span> TwistedProj(-p.x, p.y, p.z, p.curve);
<a name="l00746"></a>00746     }
<a name="l00747"></a>00747 
<a name="l00752"></a><a class="code" href="namespacee2c2.html#4c074ac760f781e8fa33b53a09a921e9">00752</a>     <span class="keyword">inline</span> TwistedProj <a class="code" href="namespacee2c2.html#eb5f6cbd2e32fd1d6b02e4e436f266d0" title="Projective point doubling on odd curve.">proj_double</a>(<span class="keyword">const</span> TwistedProj&amp; p) {
<a name="l00755"></a>00755         <span class="keyword">auto</span> b = NTL::sqr(p.x + p.y);
<a name="l00756"></a>00756         <span class="keyword">auto</span> c = NTL::sqr(p.x);
<a name="l00757"></a>00757         <span class="keyword">auto</span> d = NTL::sqr(p.y);
<a name="l00758"></a>00758         <span class="keyword">auto</span> e = p.curve.c * c;
<a name="l00759"></a>00759         <span class="keyword">auto</span> f = e + d;
<a name="l00760"></a>00760         <span class="keyword">auto</span> h = NTL::sqr(p.z);
<a name="l00761"></a>00761         <span class="keyword">auto</span> j = f - 2 * h;
<a name="l00762"></a>00762         <span class="keywordflow">return</span> TwistedProj((b - c - d) * j, f * (e - d), f * j, p.curve);
<a name="l00763"></a>00763     }
<a name="l00764"></a>00764 }
<a name="l00765"></a>00765 
<a name="l00766"></a>00766 
<a name="l00767"></a>00767 
<a name="l00768"></a>00768 <span class="preprocessor">#endif  // _POINTS_H</span>
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Mar 27 21:09:51 2013 for e2c2 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.9 </small></address>
</body>
</html>
